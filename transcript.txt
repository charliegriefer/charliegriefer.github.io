
*** #inst "2014-09-10T04:07:07.202-00:00" ***
=> (clojure.core/binding [clojure.core/*ns* (clojure.core/symbol "reply.eval-modes.nrepl")] (set! *print-length* nil))nil
=> (do (do (do (clojure.core/println (clojure.core/str "REPL-y " "0.3.2" ", nREPL " (:version-string clojure.tools.nrepl/version))) (clojure.core/println "Clojure" (clojure.core/clojure-version)) (clojure.core/println (java.lang.System/getProperty "java.vm.name") (java.lang.System/getProperty "java.runtime.version")) (clojure.core/use (quote [clojure.repl :only [source apropos dir]])) (clojure.core/when (clojure.core/ns-resolve (quote clojure.repl) (quote pst)) (clojure.core/refer (quote clojure.repl) :only (quote [pst doc find-doc]))) (clojure.core/use (quote [clojure.java.javadoc :only [javadoc]])) (clojure.core/use (quote [clojure.pprint :only [pp pprint]])) (clojure.core/create-ns (quote reply.exports)) (intern (quote reply.exports) (quote original-ns) *ns*) (clojure.core/in-ns (quote reply.exports)) (clojure.core/refer (quote clojure.core)) (defn intern-with-meta [ns sym value-var] (intern ns (with-meta sym (meta value-var)) (clojure.core/deref value-var))) (clojure.core/defn help [] (println "    Docs: (doc function-name-here)\n          (find-doc \"part-of-name-here\")\n  Source: (source function-name-here)\n Javadoc: (javadoc java-object-or-class-here)\n    Exit: Control+D or (exit) or (quit)\n Results: Stored in vars *1, *2, *3, an exception in *e\n")) (intern-with-meta (quote user) (quote help) (var help)) (defn unresolve "Given a var, return a sequence of all symbols that resolve to the\n  var from the current namespace *ns*." [var] (when-not (instance? clojure.lang.Var var) (throw (Exception. (format "unresolve: first arg must be Var")))) (let [home-ns (.ns var) sym-name-str (second (re-find #"/(.*)$" (str var)))] (sort-by (fn* [p1__698#] (count (str p1__698#))) (concat (->> (ns-map *ns*) (filter (fn [[k v]] (= var v))) (map first)) (list (symbol (str home-ns) sym-name-str)) (->> (ns-aliases *ns*) (filter (fn [[ns-alias ns]] (= ns home-ns))) (map first) (map (fn [ns-alias-symbol] (symbol (str ns-alias-symbol) sym-name-str)))))))) (defn apropos-better "Similar to clojure.repl/apropos, but provides enough context (in the form of\n  namespaces where the vars live, when necessary) to actually use the results\n  in a REPL.\n\n  Given a regular expression or stringable thing, calculate a\n  sequence of all symbols in all currently-loaded namespaces such that\n  it matches the str-or-pattern, with at most one such symbol per Var.\n  The sequence returned contains symbols that map to those Vars, and are\n  the shortest symbols that map to the Var, when qualified with the\n  namespace name or alias, if that qualification is necessary to name\n  the Var.  Note that it is possible the symbol returned does not match\n  the str-or-pattern itself, e.g. if the symbol-to-var mapping was\n  created with :rename.\n\n  Searches through all non-Java symbols in the current namespace, but\n  only public symbols of other namespaces." [str-or-pattern] (let [matches? (if (instance? java.util.regex.Pattern str-or-pattern) (fn* [p1__702#] (re-find str-or-pattern (str p1__702#))) (fn* [p1__703#] (.contains (str p1__703#) (str str-or-pattern))))] (sort (map (fn* [p1__704#] (first ((ns-resolve (quote reply.exports) (quote unresolve)) p1__704#))) (set (mapcat (fn [ns] (map second (filter (fn [[s v]] (matches? s)) (if (= ns *ns*) (concat (ns-interns ns) (ns-refers ns)) (ns-publics ns))))) (all-ns))))))) (intern-with-meta (quote user) (quote apropos-better) (var apropos-better)) (intern-with-meta (quote user) (quote find-name) (var apropos-better)) (def clojuredocs-available? (delay (try (println "Loading clojuredocs-client...") (require (quote [cd-client.core])) true (catch Exception e# (println "Warning: Could not load the ClojureDocs client, so" "`clojuredocs` will be unavailable") (println "  Details:" e# "\n") false)))) (defn call-with-ns-and-name [f v] (let [m (meta v) ns (str (.name (:ns m))) name (str (:name m))] (f ns name))) (defmacro handle-fns-etc [name fn] (if (special-symbol? name) (clojure.core/seq (clojure.core/concat (clojure.core/list fn) (clojure.core/list "clojure.core") (clojure.core/list (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/str)) (clojure.core/list (clojure.core/seq (clojure.core/concat (clojure.core/list (quote quote)) (clojure.core/list name))))))))) (let [nspace (find-ns name)] (if nspace (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/println)) (clojure.core/list "No usage examples for namespaces as a whole like") (clojure.core/list (clojure.core/seq (clojure.core/concat (clojure.core/list (quote quote)) (clojure.core/list name)))) (clojure.core/list "\nTry a particular symbol in a namespace,") (clojure.core/list "e.g. clojure.string/join"))) (clojure.core/seq (clojure.core/concat (clojure.core/list (quote reply.exports/call-with-ns-and-name)) (clojure.core/list fn) (clojure.core/list (clojure.core/seq (clojure.core/concat (clojure.core/list (quote var)) (clojure.core/list name)))))))))) (defmacro lazy-clojuredocs "Lazily checks if the clojuredocs client is available, and uses it to\n  retrieve examples if it is." ([v] (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/when)) (clojure.core/list (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/deref)) (clojure.core/list (quote reply.exports/clojuredocs-available?))))) (clojure.core/list (clojure.core/seq (clojure.core/concat (clojure.core/list (quote reply.exports/handle-fns-etc)) (clojure.core/list v) (clojure.core/list (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/ns-resolve)) (clojure.core/list (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/symbol)) (clojure.core/list "cd-client.core")))) (clojure.core/list (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/symbol)) (clojure.core/list "pr-examples-core"))))))))))))) ([ns-str var-str] (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/when)) (clojure.core/list (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/deref)) (clojure.core/list (quote reply.exports/clojuredocs-available?))))) (clojure.core/list (clojure.core/seq (clojure.core/concat (clojure.core/list (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/ns-resolve)) (clojure.core/list (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/symbol)) (clojure.core/list "cd-client.core")))) (clojure.core/list (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/symbol)) (clojure.core/list "pr-examples-core"))))))) (clojure.core/list ns-str) (clojure.core/list var-str)))))))) (intern-with-meta (quote user) (quote clojuredocs) (var lazy-clojuredocs)) (intern-with-meta (quote user) (quote cdoc) (var lazy-clojuredocs)) (try (clojure.core/require (quote [complete.core])) (def resolve-class (fn [sym] (try (let [val (resolve sym)] (when (class? val) val)) (catch Exception e (when (not= ClassNotFoundException (class (clojure.main/repl-exception e))) (throw e)))))) (reply.exports/intern-with-meta (quote complete.core) (quote resolve-class) (var resolve-class)) (catch java.lang.Exception e__8216__auto__ (try (clojure.core/eval (quote (do (ns complete.core (:require [clojure.main]) (:import [java.util.jar JarFile] [java.io File])) (defn namespaces "Returns a list of potential namespace completions for a given namespace" [ns] (map name (concat (map ns-name (all-ns)) (keys (ns-aliases ns))))) (defn ns-public-vars "Returns a list of potential public var name completions for a given namespace" [ns] (map name (keys (ns-publics ns)))) (defn ns-vars "Returns a list of all potential var name completions for a given namespace" [ns] (for [[sym val] (ns-map ns) :when (var? val)] (name sym))) (defn ns-classes "Returns a list of potential class name completions for a given namespace" [ns] (map name (keys (ns-imports ns)))) (def special-forms (map name (quote [def if do let quote var fn loop recur throw try monitor-enter monitor-exit dot new set!]))) (defn- static? [member] (java.lang.reflect.Modifier/isStatic (.getModifiers member))) (defn ns-java-methods "Returns a list of potential java method name completions for a given namespace" [ns] (for [class (vals (ns-imports ns)) method (.getMethods class) :when (static? method)] (str "." (.getName method)))) (defn static-members "Returns a list of potential static members for a given class" [class] (for [member (concat (.getMethods class) (.getDeclaredFields class)) :when (static? member)] (.getName member))) (defn path-files [path] (cond (.endsWith path "/*") (for [jar (.listFiles (File. path)) :when (.endsWith (.getName jar) ".jar") file (path-files (.getPath jar))] file) (.endsWith path ".jar") (try (for [entry (enumeration-seq (.entries (JarFile. path)))] (.getName entry)) (catch Exception e)) :else (for [file (file-seq (File. path))] (.replace (.getPath file) path "")))) (def classfiles (for [prop ["sun.boot.class.path" "java.ext.dirs" "java.class.path"] path (.split (System/getProperty prop) File/pathSeparator) file (path-files path) :when (and (.endsWith file ".class") (not (.contains file "__")))] file)) (defn- classname [file] (.. file (replace ".class" "") (replace File/separator "."))) (def top-level-classes (future (doall (for [file classfiles :when (re-find #"^[^\$]+\.class" file)] (classname file))))) (def nested-classes (future (doall (for [file classfiles :when (re-find #"^[^\$]+(\$[^\d]\w*)+\.class" file)] (classname file))))) (defn resolve-class [sym] (try (let [val (resolve sym)] (when (class? val) val)) (catch Exception e (when (not= ClassNotFoundException (class (clojure.main/repl-exception e))) (throw e))))) (defmulti potential-completions (fn [prefix ns] (cond (.contains prefix "/") :scoped (.contains prefix ".") :class :else :var))) (defmethod potential-completions :scoped [prefix ns] (let [scope (symbol (first (.split prefix "/")))] (map (fn* [p1__705#] (str scope "/" p1__705#)) (if-let [class (resolve-class scope)] (static-members class) (when-let [ns (or (find-ns scope) (scope (ns-aliases ns)))] (ns-public-vars ns)))))) (defmethod potential-completions :class [prefix ns] (concat (namespaces ns) (if (.contains prefix "$") (clojure.core/deref nested-classes) (clojure.core/deref top-level-classes)))) (defmethod potential-completions :var [_ ns] (concat special-forms (namespaces ns) (ns-vars ns) (ns-classes ns) (ns-java-methods ns))) (defn completions "Return a sequence of matching completions given a prefix string and an optional current namespace." ([prefix] (completions prefix *ns*)) ([prefix ns] (sort (for [completion (potential-completions prefix ns) :when (.startsWith completion prefix)] completion))))))) (catch java.lang.Exception f__8217__auto__ (clojure.core/intern (clojure.core/create-ns (quote complete.core)) (quote completions) (clojure.core/fn [prefix__8218__auto__ ns__8219__auto__] [])) (clojure.core/println "Unable to initialize completions."))))) (clojure.core/in-ns (clojure.core/ns-name reply.exports/original-ns)) (user/help) nil) nil nil nil))=> => (in-ns 'user)
            (println "\nError loading namespace; falling back to user")#<Namespace user>
=> eit